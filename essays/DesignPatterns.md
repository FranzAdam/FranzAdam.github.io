---
layout: essay
type: essay
title: DesignPatterns
# All dates must be YYYY-MM-DD format!
date: 2020-12-02
labels:
  - Design Patterns
  - Learning
---
Over the last 40 years the world record in the 100m freestyle in swimming has dropped almost three seconds. For anyone that does not follow swimming, let me tell you that this is a significant amount of time. Every year, the D1 national collegiate championship cuts get faster as they have been the year before and every year experts say that it will come to a halt, but it does not. So, what is the reason for that. People do not just get stronger and faster within one generation. Also, the equipment does not change, they are still using a suit, caps and goggles.
The main change that leads to such a steady increase in swimmers performance and in general performance of all athletes is the way they train. To be more specific, it is the way they are coached. Every year, with every athlete, coaches figure out ways to get athletes to a certain performance quicker and more efficient. Athletes reach certain milestone, say a certain time on a certain distance, much more quickly than they used to 10 and 20 years ago. There are certain problems that need to be solved to advance to a higher level. Technique, strength, nutrition, and mindset; all these areas include problems, that when solving them lead to an increase to the overall performance of an athlete. Every new athlete and coach starting off nowadays, has all these years of previous experience available. They have a head start and advantage in knowledge compared to previous athletes. 
But how is this relevant in any way to Software Engineering? Well I think there is a correlation between sports and design patterns in Software Engineering. They also build on commonly occurring problems and their solutions that were once discovered and are now widely applied and used. Reusable solutions to high volume problems are commonly used in every field of study and going back to Software Engineering, that is exactly what design patterns are. 
Hard acquired work of professors and researchers in the field are used to help beginners get a head start and so at the end faster integrate them to the current level of research. This is the same fore me, I am a beginner and I am using solutions and knowledge templates, a product of trial and error of fellow professors and people in this field, to improve my learning to be able to catch up on knowledge to them one day. In ICS 314, where I had my first experiences with actual software engineering, I not knowingly have been using design patterns already. At my final project, my team and me have been using the Prototype design pattern in our Collection classes, which are encapsulations of Mongo Collections. Also, I think we have been using a similar concept to the observer throughout the entire project back end. The publish and subscribe ‘tool’ in Meteor that helps us with the data processing on the server.
However many actual design patterns I have used in this class, I do not understand the underlying project yet and the actual benefit these patterns bring. I have not run into the problems the people before me have and I have not broken my head over some concepts because there was no elegant solution to them yet. The question is do I have to? Do people have to waste their time on problems that are already solved? I think they do not and should not. If there is a key conceptual understanding for a subject that can only be made by trial and error for a certain problem, then I do support sending student on the hunt for the already existing solution. If not however, I think that students need to be educated as soon as possible to the level on which they are able to do their own research and contribute to future students by solving problems by trial and error that once will be taught in school. 

Lastly, this part of my essay will serve my future self, which hopefully will be reading this in order to refresh on design patterns in preparation for a job interview and also everyone that could make use of a small reiteration on four basic design patterns.
# Factory
Problem Description: “Creates objects without exposing underlying logic, potentially returning objects associated with different classes and/or creating dependent objects.” -Philip Johnson
Factory allows you to return and create instances of multiple classes from one super- or parent-class. Looking at the picture below, ShapeFactory will allow you to create single instances of Circle, Square and Rectangle all extending and implemented by super-class Shape. Factory also allows you to build additional dependent object on the already existing one, making it a very useful, but slightly complicated design pattern. 
![FactoryShape](Factory.png)
# Singleton
Problem Description: “Provide a global variable in an object-oriented language that does not support global variable, and/or provide complex global state” -Philip Johnson
Singleton allows you to create a variable that has only one instance and provides one “global state”. The implementation is easy and most of the time it only happened in the moment it is needed. Unless handled very carefully, usage of global state is unwise and not thread-safe. 
# Observer
Problem Description: “When a set of objects (called the ‘Observers’) need to be informed whenever a change in state occurs to another object (called the ‘Subject’).” -Philip Johnson
The subject object can maintain some sort of observer collection, including all kinds of observers for different parts of events. Once those events experience a change of state, then the subject will notify the observer of this event. This is a very common scenario in event-driven systems. Advantages include open-ended numbers of dependencies that can be changed at run-time. Disadvantages include room for poor implementation that can lead to performance issues and race conditions in multi-threaded systems.    
# MVC
Problem Description: “When implementing a user interface, it is desirable to decouple the internal representation of information from the way it is presented to and accepted from the user.” -Philip Johnson
A Model-View-Controller defines the application behavior on Model and View, decides which one is presented and splits them up to allow easy accessibility to both at the same time. The Model component can be seen as the Database or the Back End of one application and the View component can be seen as its Front-End. A big advantage MVC offers is splitting up work by people with different skills. One disadvantage is its complexity/learning curve. 
